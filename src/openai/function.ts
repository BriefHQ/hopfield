import {
  BaseHopfieldFunction,
  type DisabledTypes,
  type HopfieldFunctionOptions,
  type TypeTemplates,
} from '../function.js';
import type { SentenceOrError } from '../types.js';

import {
  ZodFirstPartyTypeKind,
  type ZodFunction,
  type ZodTuple,
  type ZodTypeAny,
  z,
} from 'zod';

const disallowedTypes = [
  ZodFirstPartyTypeKind.ZodAny,
  ZodFirstPartyTypeKind.ZodBigInt,
  ZodFirstPartyTypeKind.ZodTuple,
] as const satisfies readonly ZodFirstPartyTypeKind[];

const openAITypeTemplates = {
  ZodEnum: (description: string) =>
    `${description} This must always be a possible value from the \`enum\` array.` as const,
} as const satisfies TypeTemplates;

const openAITemplates = {
  enum: <D extends string>(description: SentenceOrError<D>) =>
    openAITypeTemplates.ZodEnum(description),
} as const;

const stringToJSONSchema = z.string().transform((str, ctx): object => {
  try {
    return JSON.parse(str);
  } catch (_e) {
    ctx.addIssue({ code: 'custom', message: 'Invalid JSON' });
    return z.NEVER;
  }
});

export type OpenAIHopfieldFunctionProps<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny,
  ZFunction extends ZodFunction<Args, Returns>,
  FName extends string,
  D extends DisabledTypes,
  T extends TypeTemplates,
> = {
  schema: ZFunction;
  name: FName;
  options?: HopfieldFunctionOptions<D, T>;
};

export class OpenAIHopfieldFunction<
  ZFunctionArgs extends ZodTuple<any, any>,
  ZFunctionReturns extends ZodTypeAny,
  ZFunction extends ZodFunction<ZFunctionArgs, ZFunctionReturns>,
  FName extends string,
  DTypes extends DisabledTypes = typeof disallowedTypes,
  TTemplates extends TypeTemplates = typeof openAITypeTemplates,
> extends BaseHopfieldFunction<
  ZFunctionArgs,
  ZFunctionReturns,
  ZFunction,
  FName,
  DTypes,
  TTemplates
> {
  constructor({
    schema,
    name,
    options,
  }: OpenAIHopfieldFunctionProps<
    ZFunctionArgs,
    ZFunctionReturns,
    ZFunction,
    FName,
    DTypes,
    TTemplates
  >) {
    super({
      schema,
      name,
      options,
    });
  }

  protected _defaultTypeTemplates() {
    return openAITypeTemplates;
  }

  protected _defaultDisabledTypes() {
    return disallowedTypes;
  }

  get returnType() {
    return z.object({
      name: z.enum([this.name]).describe('The name of the function to call.'),
      arguments: stringToJSONSchema
        .describe(
          'The arguments to call the function with, as generated by the model in JSON format and coerced into the provided schema. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema.',
        )
        .transform((obj) => {
          const result = this.parameters.safeParse(obj);
          if (!result.success) {
            throw result.error;
          }
          return result.data;
        }),
    });
  }

  static templates = openAITemplates;

  /**
   *
   */
  static schema<
    ZFunctionArgs extends ZodTuple<any, any>,
    ZFunctionReturns extends ZodTypeAny,
    ZFunction extends ZodFunction<ZFunctionArgs, ZFunctionReturns>,
    FName extends string,
    D extends DisabledTypes = typeof disallowedTypes,
    T extends TypeTemplates = typeof openAITypeTemplates,
  >(
    opts: OpenAIHopfieldFunctionProps<
      ZFunctionArgs,
      ZFunctionReturns,
      ZFunction,
      FName,
      D,
      T
    >,
  ) {
    return new OpenAIHopfieldFunction(opts);
  }
}

export type OpenAIFunctionSchema = ReturnType<
  typeof OpenAIHopfieldFunction.schema
>;
