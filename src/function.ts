import { BaseHopfieldSchema } from './base.js';
import { BaseError } from './errors.js';
import { zodToJsonSchema, type JsonSchema7Type } from 'zod-to-json-schema';

import type { BaseHopfieldChatTemplate, TypeTemplates } from './template.js';
import type { IsEmptyArray } from './type-utils.js';
import { z, type ZodType } from 'zod';

export type AnyBaseHopfieldFunction = BaseHopfieldFunction<
  any,
  any,
  any,
  any,
  any
>;

type FunctionProperty<
  T extends AnyBaseHopfieldFunction,
  K extends keyof T,
> = T extends { [_P in K]: infer N } ? N : never;

export type FunctionPropertyOrNever<
  T extends AnyBaseHopfieldFunction[],
  K extends keyof T[number],
> = IsEmptyArray<T> extends true
  ? never
  : [FunctionProperty<T[number], K>, ...FunctionProperty<T[number], K>[]];

export interface JsonSchemaFunction<
  Name extends string,
  Description extends string = string,
> {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain
   * underscores and dashes, with a maximum length of 64.
   */
  name: Name;
  /**
   * A description of what the function does, used by the model to choose when and
   * how to call the function.
   */
  description: Description;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the
   * [guide](/docs/guides/gpt/function-calling) for examples, and the
   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
   * documentation about the format.
   *
   * To describe a function that accepts no parameters, provide the value
   * `{"type": "object", "properties": {}}`.
   */
  parameters: JsonSchema7Type;
}

const stringToJSONSchema = z.string().transform((str, ctx): object => {
  try {
    return JSON.parse(str);
  } catch (_e) {
    ctx.addIssue({
      code: 'custom',
      message:
        'Invalid JSON when parsing - likely the arguments are malformed.',
    });
    return z.NEVER;
  }
});

const NameSchema = z
  .string()
  .max(64, {
    message: "Function name can't exceed 64 characters.",
  })
  .refine((value) => /^[a-zA-Z0-9_-]+$/.test(value), {
    message:
      'Function name can only contain a-z, A-Z, 0-9, underscores and dashes.',
  });

const DescriptionSchema = z.string().min(1).max(500);

export type BaseHopfieldFunctionProps<
  FName extends string,
  FDescription extends string,
  FParams extends ZodType<any, any, any>,
  TTemplates extends TypeTemplates,
  Template extends BaseHopfieldChatTemplate<TTemplates>,
> = {
  name: FName;
  description: FDescription;
  parameters: FParams;
  template: Template;
};

export abstract class BaseHopfieldFunction<
  FName extends string,
  FDescription extends string,
  FParams extends ZodType<any, any, any>,
  TTemplates extends TypeTemplates,
  Template extends BaseHopfieldChatTemplate<TTemplates>,
> extends BaseHopfieldSchema<FParams> {
  name: FName;
  description: FDescription;

  parameters: FParams;
  protected _template: Template;

  constructor({
    name,
    description,
    parameters,
    template,
  }: BaseHopfieldFunctionProps<
    FName,
    FDescription,
    FParams,
    TTemplates,
    Template
  >) {
    super();

    this.name = name;
    this.description = description;
    this.parameters = parameters;

    this._template = template;
  }

  protected abstract get _defaultTypeTemplates(): TypeTemplates;

  /**
   * Returns a formatted JSON schema function definition for LLM function calling.
   * This is checked for correctness against the provided rules, so make sure this is only done
   * once and not called repeatedly in the critical path.
   *
   * @returns @interface JsonSchemaFunction a definition for a valid JSON schema function.
   */
  get jsonSchema(): JsonSchemaFunction<FName> {
    const parsedName = NameSchema.safeParse(this.name);
    const parsedDescription = DescriptionSchema.safeParse(this.description);

    if (!parsedName.success) {
      throw new BaseError('You must define a valid function name.', {
        docsPath: '/chat/functions',
        details: parsedName.error,
      });
    }
    if (!parsedDescription.success) {
      throw new BaseError('You must define a valid function description.', {
        docsPath: '/chat/functions',
        details: parsedDescription.error,
      });
    }

    return {
      name: this.name,
      description: this.description,
      parameters: zodToJsonSchema(this.parameters as any, {
        $refStrategy: 'none',
      }) as object,
    } as const;
  }

  get returnType() {
    return z.object({
      name: z.literal(this.name).describe('The name of the function to call.'),
      arguments: stringToJSONSchema
        .describe(
          'The arguments to call the function with, as generated by the model in JSON format and coerced into the provided schema. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema.',
        )
        .transform((obj) => {
          const result = this.parameters.safeParse(obj);
          if (!result.success) {
            throw result.error;
          }
          return result.data;
        }) as unknown as typeof this.parameters,
    });
  }

  get schema() {
    return z.object({
      name: z.literal(this.name).describe('The name of the function.'),
      description: z
        .literal(this.description)
        .describe('The description of the function.'),
      parameters: z
        .object({
          type: z.literal('object'),
          properties: z.record(z.any()).optional(),
          required: z.array(z.string()).optional(),
          additionalProperties: z.boolean(),
          $schema: z.string(),
        })
        .passthrough(),
    });
  }
}
